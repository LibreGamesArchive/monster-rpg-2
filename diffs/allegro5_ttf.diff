diff --git a/addons/ttf/ttf.c b/addons/ttf/ttf.c
index a8e753b..0642f36 100644
--- a/addons/ttf/ttf.c
+++ b/addons/ttf/ttf.c
@@ -15,6 +15,8 @@
 
 #include <stdlib.h>
 
+#include "../primitives/allegro5/allegro_primitives.h"
+
 ALLEGRO_DEBUG_CHANNEL("font")
 
 
@@ -33,6 +35,152 @@ ALLEGRO_DEBUG_CHANNEL("font")
 
 #define RANGE_SIZE   128
 
+static ALLEGRO_VERTEX *ttf_vertex_cache;
+static int ttf_cache_size = 0;
+static ALLEGRO_BITMAP *ttf_cache_bitmap;
+static bool ttf_caching;
+static int ttf_vcount = 0;
+
+static ALLEGRO_BITMAP *ttf_real_bitmap(ALLEGRO_BITMAP *bitmap)
+{
+	if (bitmap == 0) {
+		return 0;
+	}
+	ALLEGRO_BITMAP *parent = bitmap;
+	while (al_is_sub_bitmap(parent)) {
+		parent = al_get_parent_bitmap(parent);
+	}
+	return parent;
+}
+
+static void ttf_quick_resize_cache(int num_verts)
+{
+	if (ttf_vcount + num_verts <= ttf_cache_size) {
+		return;
+	}
+
+	int resize_amount = ((num_verts / 256) + 1) * 256;
+
+	ttf_cache_size += resize_amount;
+
+	ttf_vertex_cache = (ALLEGRO_VERTEX *)realloc(ttf_vertex_cache, ttf_cache_size * sizeof(ALLEGRO_VERTEX));
+}
+
+static void ttf_quick_flush(void)
+{
+	if (ttf_vcount > 0) {
+		al_draw_prim(ttf_vertex_cache, 0, ttf_cache_bitmap, 0, ttf_vcount, ALLEGRO_PRIM_TRIANGLE_LIST);
+		ttf_vcount = 0;
+	}
+	ttf_cache_bitmap = 0;
+}
+
+void ttf_quick(bool onoff);
+void ttf_quick(bool onoff)
+{
+	if (ttf_caching == onoff) {
+		return;
+	}
+
+	ttf_caching = onoff;
+
+	if (onoff == false) {
+		ttf_quick_flush();
+	}
+}
+
+bool ttf_is_quick(void);
+bool ttf_is_quick(void)
+{
+	return ttf_caching;
+}
+
+static void ttf_quick_draw(ALLEGRO_BITMAP *bitmap, ALLEGRO_COLOR tint, float sx, float sy, float sw, float sh, float dx, float dy, float dw, float dh, int flags)
+{
+	ALLEGRO_BITMAP *real = ttf_real_bitmap(bitmap);
+	if (ttf_cache_bitmap != real) {
+		ttf_quick_flush();
+		ttf_cache_bitmap = real;
+	}
+
+	ttf_quick_resize_cache(6);
+
+	ALLEGRO_VERTEX *v = &ttf_vertex_cache[ttf_vcount];
+	
+	sx += al_get_bitmap_x(bitmap);
+	sy += al_get_bitmap_y(bitmap);
+	int u1 = sx;
+	int u2 = sx + sw;
+	int v1 = sy;
+	int v2 = sy + sh;
+
+	if (flags & ALLEGRO_FLIP_HORIZONTAL) {
+		int tmp = u1;
+		u1 = u2;
+		u2 = tmp;
+	}
+	if (flags & ALLEGRO_FLIP_VERTICAL) {
+		int tmp = v1;
+		v1 = v2;
+		v2 = tmp;
+	}
+
+	v[0].x = dx;
+	v[0].y = dy;
+	v[0].z = 0;
+	v[0].u = u1;
+	v[0].v = v1;
+	v[0].color = tint;
+
+	v[1].x = dx+dw;
+	v[1].y = dy;
+	v[1].z = 0;
+	v[1].u = u2;
+	v[1].v = v1;
+	v[1].color = tint;
+	
+	v[2].x = dx+dw;
+	v[2].y = dy+dh;
+	v[2].z = 0;
+	v[2].u = u2;
+	v[2].v = v2;
+	v[2].color = tint;
+
+	v[3].x = dx;
+	v[3].y = dy;
+	v[3].z = 0;
+	v[3].u = u1;
+	v[3].v = v1;
+	v[3].color = tint;
+
+	v[4].x = dx+dw;
+	v[4].y = dy+dh;
+	v[4].z = 0;
+	v[4].u = u2;
+	v[4].v = v2;
+	v[4].color = tint;
+
+	v[5].x = dx;
+	v[5].y = dy+dh;
+	v[5].z = 0;
+	v[5].u = u1;
+	v[5].v = v2;
+	v[5].color = tint;
+
+	ttf_vcount += 6;
+
+	if (ttf_caching == false) {
+		ttf_quick_flush();
+	}
+}
+
+static void ttf_quick_shutdown(void)
+{
+	free(ttf_vertex_cache);
+	ttf_vertex_cache = 0;
+        ttf_cache_size = 0;
+}
+
 
 typedef struct REGION
 {
@@ -389,7 +537,7 @@ static void copy_glyph_color(ALLEGRO_TTF_FONT_DATA *font_data, FT_Face face,
 /* NOTE: this function may disable the bitmap hold drawing state
  * and leave the current page bitmap locked.
  * 
- * NOTE: We have previously tried to be more clever about caching multiple
+ * NOTE: We have previously tried to be more clever about ttf_caching multiple
  * glyphs during incidental cache misses, but found that approach to be slower.
  */
 static void cache_glyph(ALLEGRO_TTF_FONT_DATA *font_data, FT_Face face,
@@ -520,11 +668,20 @@ static int render_glyph(ALLEGRO_FONT const *f, ALLEGRO_COLOR color,
 
    if (glyph->page_bitmap) {
       /* Each glyph has a 1-pixel border all around. */
+      /*
       al_draw_tinted_bitmap_region(glyph->page_bitmap, color,
          glyph->region.x + 1, glyph->region.y + 1,
          glyph->region.w - 2, glyph->region.h - 2,
          xpos + glyph->offset_x + advance,
          ypos + glyph->offset_y, 0);
+	 */
+     float sx = glyph->region.x + 1;
+     float sy = glyph->region.y + 1;
+     float sw = glyph->region.w - 2;
+     float sh = glyph->region.h - 2;
+     float dx = xpos + glyph->offset_x + advance;
+     float dy = ypos + glyph->offset_y;
+     ttf_quick_draw(glyph->page_bitmap, color, sx, sy, sw, sh, dx, dy, sw, sh, 0);
    }
    else if (glyph->region.x > 0) {
       ALLEGRO_ERROR("Glyph %d not on any page.\n", ft_index);
@@ -620,8 +777,8 @@ static int ttf_render(ALLEGRO_FONT const *f, ALLEGRO_COLOR color,
    int32_t ch;
    bool hold;
 
-   hold = al_is_bitmap_drawing_held();
-   al_hold_bitmap_drawing(true);
+   bool was_ttf_quick = ttf_is_quick();
+   ttf_quick(true);
 
    while ((ch = al_ustr_get_next(text, &pos)) >= 0) {
       int ft_index = FT_Get_Char_Index(face, ch);
@@ -630,7 +787,7 @@ static int ttf_render(ALLEGRO_FONT const *f, ALLEGRO_COLOR color,
       prev_ft_index = ft_index;
    }
 
-   al_hold_bitmap_drawing(hold);
+   ttf_quick(was_ttf_quick);
 
    return advance;
 }
@@ -1097,6 +1254,8 @@ void al_shutdown_ttf_addon(void)
 
    FT_Done_FreeType(ft);
 
+   ttf_quick_shutdown();
+
    ttf_inited = false;
 }
 
